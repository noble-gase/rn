use std::time::Duration;

use bb8::ManageConnection;
use kr::manager::{bb8_redis, bb8_redis_cluster};

use crate::core::config::config;

pub type SingleManager = bb8_redis::RedisConnectionManager;

pub type ClusterManager = bb8_redis_cluster::RedisClusterManager;

pub trait RedisFactory {
    type Manager: ManageConnection<Error: std::error::Error + Send + Sync + 'static>;

    fn build(cfg_key: &str) -> anyhow::Result<Self::Manager>;
}

pub struct Single;

impl RedisFactory for Single {
    type Manager = SingleManager;

    fn build(cfg_key: &str) -> anyhow::Result<Self::Manager> {
        let dsn = config().get_string(&format!("{}.dsn", cfg_key))?;

        let client = redis::Client::open(dsn)?;
        let mut conn = client.get_connection()?;
        let _ = redis::cmd("PING").query::<String>(&mut conn)?;

        Ok(SingleManager::new(client))
    }
}

pub struct Cluster;

impl RedisFactory for Cluster {
    type Manager = ClusterManager;

    fn build(cfg_key: &str) -> anyhow::Result<Self::Manager> {
        let nodes = config()
            .get_array(&format!("{}.dsn", cfg_key))?
            .into_iter()
            .map(|v| v.to_string())
            .collect::<Vec<String>>();

        let client = redis::cluster::ClusterClient::new(nodes)?;
        let mut conn = client.get_connection()?;
        let _ = redis::cmd("PING").query::<String>(&mut conn)?;

        Ok(ClusterManager::new(client))
    }
}

/// 生成 Redis 连接池
///
/// # Examples
///
/// ```
/// // DSN
/// // redis://<host>:6379/<db>
/// // redis://:<pass>@<host>:6379/<db>
/// // redis://<user>:<pass>@<host>:6379/<db>
///
/// // 单节点
/// let x = cache::new::<cache::Single>("config-key").await;
///
/// // 集群
/// let x = cache::new::<cache::Cluster>("config-key").await;
/// ```
pub async fn new<F>(cfg_key: &str) -> anyhow::Result<bb8::Pool<F::Manager>>
where
    F: RedisFactory,
{
    let manager = F::build(cfg_key)?;

    let cfg = config();

    let max_size = cfg
        .get_int(&format!("{}.options.max_size", cfg_key))
        .unwrap_or(100);
    let min_idle = cfg
        .get_int(&format!("{}.options.min_idle", cfg_key))
        .unwrap_or(10);
    let conn_timeout = cfg
        .get_int(&format!("{}.options.conn_timeout", cfg_key))
        .unwrap_or(10);
    let idle_timeout = cfg
        .get_int(&format!("{}.options.idle_timeout", cfg_key))
        .unwrap_or(300);
    let max_lifetime = cfg
        .get_int(&format!("{}.options.max_lifetime", cfg_key))
        .unwrap_or(600);

    let pool = bb8::Pool::builder()
        .max_size(max_size as u32)
        .min_idle(Some(min_idle as u32))
        .connection_timeout(Duration::from_secs(conn_timeout as u64))
        .idle_timeout(Some(Duration::from_secs(idle_timeout as u64)))
        .max_lifetime(Some(Duration::from_secs(max_lifetime as u64)))
        .build(manager)
        .await?;

    Ok(pool)
}

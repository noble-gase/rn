use std::time::Duration;

use kr::redix;

use crate::core::config::config;

pub async fn new(cfg_key: &str) -> anyhow::Result<redix::SinglePool> {
    let cfg = config();

    let dsn = cfg.get_string(&format!("{}.dsn", cfg_key))?;

    let max_size = cfg
        .get_int(&format!("{}.options.max_size", cfg_key))
        .unwrap_or(100);
    let min_idle = cfg
        .get_int(&format!("{}.options.min_idle", cfg_key))
        .unwrap_or(10);
    let conn_timeout = cfg
        .get_int(&format!("{}.options.conn_timeout", cfg_key))
        .unwrap_or(10);
    let idle_timeout = cfg
        .get_int(&format!("{}.options.idle_timeout", cfg_key))
        .unwrap_or(300);
    let max_lifetime = cfg
        .get_int(&format!("{}.options.max_lifetime", cfg_key))
        .unwrap_or(600);

    let params = redix::Params {
        max_size: Some(max_size as u32),
        min_idle: Some(min_idle as u32),
        conn_timeout: Some(Duration::from_secs(conn_timeout as u64)),
        idle_timeout: Some(Duration::from_secs(idle_timeout as u64)),
        max_lifetime: Some(Duration::from_secs(max_lifetime as u64)),
    };

    let pool = redix::open::<redix::Single>(vec![dsn], Some(params)).await?;

    Ok(pool)
}

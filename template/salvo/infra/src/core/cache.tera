use std::time::Duration;

use bb8::ManageConnection;
use kr::manager::{bb8_redis, bb8_redis_cluster};

use crate::core::config::config;

pub type SingleConn = bb8_redis::RedisConnectionManager;

pub type ClusterConn = bb8_redis_cluster::RedisClusterManager;

pub trait RedisFactory {
    type Output: ManageConnection<Error: std::error::Error + Send + Sync + 'static>;

    fn build(cfg_key: &str) -> anyhow::Result<Self::Output>;
}

pub struct Single;

impl RedisFactory for Single {
    type Output = SingleConn;

    fn build(cfg_key: &str) -> anyhow::Result<Self::Output> {
        let dsn = config().get_string(&format!("{}.dsn", cfg_key))?;

        let client = redis::Client::open(dsn)?;
        let mut conn = client.get_connection()?;
        let _ = redis::cmd("PING").query::<String>(&mut conn)?;

        Ok(SingleConn::new(client))
    }
}

pub struct Cluster;

impl RedisFactory for Cluster {
    type Output = ClusterConn;

    fn build(cfg_key: &str) -> anyhow::Result<Self::Output> {
        let nodes = config()
            .get_array(&format!("{}.dsn", cfg_key))?
            .into_iter()
            .map(|v| v.to_string())
            .collect::<Vec<String>>();

        let client = redis::cluster::ClusterClient::new(nodes)?;
        let mut conn = client.get_connection()?;
        let _ = redis::cmd("PING").query::<String>(&mut conn)?;

        Ok(ClusterConn::new(client))
    }
}

/// 生成 Redis 连接池
///
/// # Examples
///
/// ```
/// // DSN
/// // redis://:<password>@<host>:6379/<db>
/// // redis://<username>:<password>@<host>:6379/<db>
///
/// // 单节点
/// let x = cache::new::<cache::Single>("config-key").await;
///
/// // 集群
/// let x = cache::new::<cache::Cluster>("config-key").await;
/// ```
pub async fn new<F>(cfg_key: &str) -> anyhow::Result<bb8::Pool<F::Output>>
where
    F: RedisFactory,
{
    let manager = F::build(cfg_key)?;

    let cfg = config();

    let max_size = cfg
        .get_int(&format!("{}.options.max_size", cfg_key))
        .unwrap_or(20);
    let min_idle = cfg.get_int("{}.options.min_idle").unwrap_or(10);
    let conn_timeout = cfg.get_int("{}.options.conn_timeout").unwrap_or(10);
    let idle_timeout = cfg.get_int("{}.options.idle_timeout").unwrap_or(300);
    let max_lifetime = cfg.get_int("{}.options.max_lifetime").unwrap_or(600);

    let pool = bb8::Pool::builder()
        .max_size(max_size as u32)
        .min_idle(Some(min_idle as u32))
        .connection_timeout(Duration::from_secs(conn_timeout as u64))
        .idle_timeout(Some(Duration::from_secs(idle_timeout as u64)))
        .max_lifetime(Some(Duration::from_secs(max_lifetime as u64)))
        .build(manager)
        .await?;

    Ok(pool)
}
